package todo

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.

import (
	"context"
	"fmt"

	"github.com/hewenyu/todo/ent"
)

func (r *createTempleInputResolver) Status(ctx context.Context, obj *ent.CreateTempleInput, data *TempleStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createTempleInputResolver) DeleteAt(ctx context.Context, obj *ent.CreateTempleInput, data *TempleDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createTempleInputResolver) ChildIDs(ctx context.Context, obj *ent.CreateTempleInput, data []int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createTempleInputResolver) ParentID(ctx context.Context, obj *ent.CreateTempleInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createTempleInputResolver) OwnerID(ctx context.Context, obj *ent.CreateTempleInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createUserInputResolver) Status(ctx context.Context, obj *ent.CreateUserInput, data *UserStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createUserInputResolver) DeleteAt(ctx context.Context, obj *ent.CreateUserInput, data *UserDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *createUserInputResolver) TodoIDs(ctx context.Context, obj *ent.CreateUserInput, data []int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) ID(ctx context.Context, obj *ent.TempleWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDNeq(ctx context.Context, obj *ent.TempleWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDIn(ctx context.Context, obj *ent.TempleWhereInput, data []int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDNotIn(ctx context.Context, obj *ent.TempleWhereInput, data []int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDGt(ctx context.Context, obj *ent.TempleWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDGte(ctx context.Context, obj *ent.TempleWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDLt(ctx context.Context, obj *ent.TempleWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) IDLte(ctx context.Context, obj *ent.TempleWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) Status(ctx context.Context, obj *ent.TempleWhereInput, data *TempleStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) StatusNeq(ctx context.Context, obj *ent.TempleWhereInput, data *TempleStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) StatusIn(ctx context.Context, obj *ent.TempleWhereInput, data []TempleStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) StatusNotIn(ctx context.Context, obj *ent.TempleWhereInput, data []TempleStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) DeleteAt(ctx context.Context, obj *ent.TempleWhereInput, data *TempleDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) DeleteAtNeq(ctx context.Context, obj *ent.TempleWhereInput, data *TempleDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) DeleteAtIn(ctx context.Context, obj *ent.TempleWhereInput, data []TempleDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *templeWhereInputResolver) DeleteAtNotIn(ctx context.Context, obj *ent.TempleWhereInput, data []TempleDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) ID(ctx context.Context, obj *ent.UserWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDNeq(ctx context.Context, obj *ent.UserWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDIn(ctx context.Context, obj *ent.UserWhereInput, data []int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDNotIn(ctx context.Context, obj *ent.UserWhereInput, data []int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDGt(ctx context.Context, obj *ent.UserWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDGte(ctx context.Context, obj *ent.UserWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDLt(ctx context.Context, obj *ent.UserWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) IDLte(ctx context.Context, obj *ent.UserWhereInput, data *int) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) Status(ctx context.Context, obj *ent.UserWhereInput, data *UserStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) StatusNeq(ctx context.Context, obj *ent.UserWhereInput, data *UserStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) StatusIn(ctx context.Context, obj *ent.UserWhereInput, data []UserStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) StatusNotIn(ctx context.Context, obj *ent.UserWhereInput, data []UserStatus) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) DeleteAt(ctx context.Context, obj *ent.UserWhereInput, data *UserDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) DeleteAtNeq(ctx context.Context, obj *ent.UserWhereInput, data *UserDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) DeleteAtIn(ctx context.Context, obj *ent.UserWhereInput, data []UserDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

func (r *userWhereInputResolver) DeleteAtNotIn(ctx context.Context, obj *ent.UserWhereInput, data []UserDeleteAt) error {
	panic(fmt.Errorf("not implemented"))
}

// CreateTempleInput returns CreateTempleInputResolver implementation.
func (r *Resolver) CreateTempleInput() CreateTempleInputResolver {
	return &createTempleInputResolver{r}
}

// CreateUserInput returns CreateUserInputResolver implementation.
func (r *Resolver) CreateUserInput() CreateUserInputResolver { return &createUserInputResolver{r} }

// TempleWhereInput returns TempleWhereInputResolver implementation.
func (r *Resolver) TempleWhereInput() TempleWhereInputResolver { return &templeWhereInputResolver{r} }

// UserWhereInput returns UserWhereInputResolver implementation.
func (r *Resolver) UserWhereInput() UserWhereInputResolver { return &userWhereInputResolver{r} }

type createTempleInputResolver struct{ *Resolver }
type createUserInputResolver struct{ *Resolver }
type templeWhereInputResolver struct{ *Resolver }
type userWhereInputResolver struct{ *Resolver }
